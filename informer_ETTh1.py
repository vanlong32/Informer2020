# -*- coding: utf-8 -*-
"""Informer -  Bản tuỳ chỉnh dữ liệu.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12Ne5h81AOump6ebBLIwg6AtXqMkRuUv0

## Informer Demo
"""

#!python -v

"""## Download code and dataset"""

#!git clone https://github.com/zhouhaoyi/Informer2020.git
#!git clone https://github.com/vanlong32/ETDataset.git
#!ls

# Module sys trong Python cung cấp các hàm và các biến được sử dụng để thao tác các phần khác nhau của môi trường chạy Python.
# Nó cho phép chúng ta truy cập các tham số và chức năng cụ thể của hệ thống.
import sys

# nếu không tìm thấy thư mục Informer2020 thì sửa lại đường dẫn
if not 'Informer2020' in sys.path:
    sys.path += ['Informer2020']

# cài này dùng để cài tất cả thư viện cần thiết
# !pip install -r ./Informer2020/requirements.txt

"""## Cấu hình

**args là gì? args** chỉ là một biến lưu cấu hình giống JSON


"""

# nhập từ tư viện informer2000, không biết để làm gì 
from utils.tools import dotdict

# nhập từ tư viện informer2000, không biết để làm gì 
from exp.exp_informer import Exp_Informer

# PyTorch làm thư viện máy học tương tự như tensoflow
import torch

args = dotdict()

args.model = 'informer' # model của thử nghiệm, tùy chọn: [informer, informerstack, informerlight(TBD)]

# chọn hình thức nhập dữ liệu, ETTh1, ETTh2, ETTm1. Nếu là dữ liệu tuỳ chỉnh thì nhập custom
args.data = 'ETTh1' # data
args.root_path = './ETDataset/ETT-small/' # root path of data file

# ETT là bộ dữ liệu của nhà máy điện
# ETTm1.csv, ETTm2.csv là Bộ dữ liệu ghi theo phút  (ký hiệu m)
# ETTh1.csv, ETTh2.csv là Bộ dữ liệu ghi theo giờ (ký hiệu bằng h)
args.data_path = 'ETTh1.csv' 


# forecasting task, tùy chọn:[M, S, MS]; 
#   - M:multivariate predict multivariate (đa biến dự đoán đa biến)
#   - S:univariate predict univariate (đơn biến dự đoán đơn biến
# ). Chương trình sẽ chỉ đọc 1 cột target. Các cột còn lại bỏ qua. 
#   - MS:multivariate predict univariate (dự đoán đa biến đơn biến)

args.features = 'M' 

# lựa chọn mục tiêu trong chế độ S or MS task
args.target = 'OT' 

# freq for time features encoding (tần số cho nhiệm vụ dự đoán)
#   tùy chọn :[s:secondly, t:minutely, h:hourly, d:daily, b:business days, w:weekly, m:monthly], 
#   bạn cũng có thể sử dụng freq chi tiết hơn như 15 phút hoặc 3 giờ

args.freq = 'h' 

# Cài vị trí lưu model checkpoints
args.checkpoints = './informer_checkpoints' 

# input sequence length of Informer encoder (độ dài chuỗi đầu vào của bộ mã hóa Informer)
args.seq_len = 96 

# start token length of Informer decoder (độ dài mã thông báo bắt đầu của bộ giải mã Inform)
args.label_len = 48 

# prediction sequence length (độ dài chuỗi dự đoán)
args.pred_len = 24



# Informer decoder input: concat[start token series(label_len), zero padding series(pred_len)]

args.enc_in = 7 # encoder input size
args.dec_in = 7 # decoder input size
args.c_out = 7 # output size
args.factor = 5 # probsparse attn factor (hệ số suy giảm xác suất)
args.d_model = 1024 # dimension of model (kích thước của mô hình)
args.n_heads = 8 # num of heads
args.e_layers = 2 # num of encoder layers
args.d_layers = 1 # num of decoder layers
args.d_ff = 2048 # dimension of fcn in model
args.dropout = 0.05 # dropout
args.attn = 'prob' # attention (chú ý) used in encoder, options:[prob, full]
args.embed = 'timeF' # time features encoding (tính năng mã hóa thời gian), options:[timeF, fixed, learned]
args.activation = 'gelu' # activation (activation)
args.distil = True # whether to use distilling in encoder (có nên sử dụng phương pháp chưng cất trong bộ mã hóa không)
args.output_attention = False # whether to output attention in ecoder (có tạo sự chú ý trong bộ sinh thái không)
args.mix = True
args.padding = 0

args.batch_size = 32 
args.learning_rate = 0.0001
args.loss = 'mse'
args.lradj = 'type1'
args.use_amp = False # whether to use automatic mixed precision training

args.num_workers = 0
args.itr = 1
args.train_epochs = 1
args.patience = 3 # kiên nhẫn
args.des = 'exp'

args.use_gpu = True if torch.cuda.is_available() else False
args.gpu = 0

args.use_multi_gpu = False
args.devices = '0,1,2,3'

args.use_gpu = True if torch.cuda.is_available() and args.use_gpu else False

if args.use_gpu and args.use_multi_gpu:
    args.devices = args.devices.replace(' ','')
    device_ids = args.devices.split(',')
    args.device_ids = [int(id_) for id_ in device_ids]
    args.gpu = args.device_ids[0]


"""### In ra cấu hình
tất cả code phía trên chỉ là khai báo cấu hình bằng text. 

"""

print('Tất cả các Args (thông số cấu hình):')
print(args)



"""## Huấn luyện - Train and Test"""

Exp = Exp_Informer

# args.itr
for ii in range(args.itr):
    
    '''
    Cái này dùng để tạo tên để lưu checkpoint, gồm các thông số cấu hình lưu vào tên 
    Loại: str 
    
    '''
    setting = '{}_{}_ft{}_sl{}_ll{}_pl{}_dm{}_nh{}_el{}_dl{}_df{}_at{}_fc{}_eb{}_dt{}_mx{}_{}_{}'.format(args.model, args.data, args.features, 
                args.seq_len, args.label_len, args.pred_len,
                args.d_model, args.n_heads, args.e_layers, args.d_layers, args.d_ff, args.attn, args.factor, args.embed, args.distil, args.mix, args.des, ii)

    # set thí nghiệm
    # bên trong chạy hàm khởi tạo. chạy qua 3 dòng code không có gì đặc biệt
    exp = Exp(args)

    # train
    print('>>>>>>>start training : {}>>>>>>>>>>>>>>>>>>>>>>>>>>'.format(setting))
    exp.train(setting)
    
    # test
    print('>>>>>>>testing : {}<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'.format(setting))
    exp.test(setting)

    torch.cuda.empty_cache()


























import os

# Đường dẫn lưu mô hình
#setting = 'informer_ETTh1_ftM_sl96_ll48_pl24_dm512_nh8_el2_dl1_df2048_atprob_fc5_ebtimeF_dtTrue_mxTrue_exp_0'


# path = os.path.join(args.checkpoints,setting,'checkpoint.pth')

# If you already have a trained model, you can set the arguments and model path, then initialize a Experiment and use it to predict
# Prediction is a sequence which is adjacent to the last date of the data, and does not exist in the data
# If you want to get more information about prediction, you can refer to code `exp/exp_informer.py function predict()` and `data/data_loader.py class Dataset_Pred`

# Nếu bạn đã có một mô hình được đào tạo, bạn có thể đặt các đối số và đường dẫn mô hình, sau đó khởi chạy Thử nghiệm và sử dụng nó để dự đoán
# Dự đoán là một chuỗi liền kề với ngày cuối cùng của dữ liệu và không tồn tại trong dữ liệu
# Nếu bạn muốn biết thêm thông tin về dự đoán, bạn có thể tham khảo mã `exp / exp_informer.py hàm dự đoán () 'và` data / data_loader.py lớp Dataset_Pred`

exp = Exp(args)

exp.predict(setting, True)

# the prediction will be saved in ./results/{setting}/real_prediction.npy
import numpy as np

prediction = np.load('./results/'+setting+'/real_prediction.npy')

prediction.shape

"""### Thông tin chi tiết về dự đoán và - prediction function"""

# Đây là code chi tiết của function predict

def predict(exp, setting, load=False):
    pred_data, pred_loader = exp._get_data(flag='pred')
        
    if load:
        path = os.path.join(exp.args.checkpoints, setting)
        best_model_path = path+'/'+'checkpoint.pth'
        exp.model.load_state_dict(torch.load(best_model_path))

    exp.model.eval()
        
    preds = []
        
    for i, (batch_x,batch_y,batch_x_mark,batch_y_mark) in enumerate(pred_loader):
        batch_x = batch_x.float().to(exp.device)
        batch_y = batch_y.float()
        batch_x_mark = batch_x_mark.float().to(exp.device)
        batch_y_mark = batch_y_mark.float().to(exp.device)

        # decoder input
        if exp.args.padding==0:
            dec_inp = torch.zeros([batch_y.shape[0], exp.args.pred_len, batch_y.shape[-1]]).float()
        elif exp.args.padding==1:
            dec_inp = torch.ones([batch_y.shape[0], exp.args.pred_len, batch_y.shape[-1]]).float()
        else:
            dec_inp = torch.zeros([batch_y.shape[0], exp.args.pred_len, batch_y.shape[-1]]).float()
        dec_inp = torch.cat([batch_y[:,:exp.args.label_len,:], dec_inp], dim=1).float().to(exp.device)
        # encoder - decoder
        if exp.args.use_amp:
            with torch.cuda.amp.autocast():
                if exp.args.output_attention:
                    outputs = exp.model(batch_x, batch_x_mark, dec_inp, batch_y_mark)[0]
                else:
                    outputs = exp.model(batch_x, batch_x_mark, dec_inp, batch_y_mark)
        else:
            if exp.args.output_attention:
                outputs = exp.model(batch_x, batch_x_mark, dec_inp, batch_y_mark)[0]
            else:
                outputs = exp.model(batch_x, batch_x_mark, dec_inp, batch_y_mark)
        f_dim = -1 if exp.args.features=='MS' else 0
        batch_y = batch_y[:,-exp.args.pred_len:,f_dim:].to(exp.device)
        
        pred = outputs.detach().cpu().numpy()#.squeeze()
        
        preds.append(pred)

    preds = np.array(preds)
    preds = preds.reshape(-1, preds.shape[-2], preds.shape[-1])
    
    # result save
    folder_path = './results/' + setting +'/'
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)
    
    np.save(folder_path+'real_prediction.npy', preds)
    
    return preds

# bạn có thể sử dụng prediction function để lấy kết quả dự đoán
prediction = predict(exp, setting, True)

import matplotlib.pyplot as plt

plt.figure()
plt.plot(prediction[0,:,-1])
plt.show()

"""### Thêm chi tiết về Dự đoán - prediction dataset

You can give a `root_path` and `data_path` of the data you want to forecast, and set `seq_len`, `label_len`, `pred_len` and other arguments as other Dataset. The difference is that you can set a more detailed freq such as `15min` or `3h` to generate the timestamp of prediction series.

`Dataset_Pred` only has one sample (including `encoder_input: [1, seq_len, dim]`, `decoder_token: [1, label_len, dim]`, `encoder_input_timestamp: [1, seq_len, date_dim]`, `decoder_input_timstamp: [1, label_len+pred_len, date_dim]`). It will intercept the last sequence of the given data (seq_len data) to forecast the unseen future sequence (pred_len data).

**Dịch:**

Bạn có thể cung cấp đường dẫn gốc và đường dẫn dữ liệu của dữ liệu bạn muốn dự báo, đồng thời đặt seq_len, label_len, pred_len và các đối số khác làm Tập dữ liệu khác. Sự khác biệt là bạn có thể đặt tần suất chi tiết hơn chẳng hạn như 15 phút hoặc 3 giờ để tạo dấu thời gian của chuỗi dự đoán. Dataset_Pred chỉ có một mẫu (bao gồm encoder_input: [1, seq_len, dim], decoder_token: [1, label_len, dim], encoder_input_timestamp: [1, seq_len, date_dim], decoder_input_timstamp: [1, label_len + pred_len, date_dim]). Nó sẽ chặn chuỗi cuối cùng của dữ liệu đã cho (dữ liệu seq_len) để dự báo chuỗi tương lai không nhìn thấy (dữ liệu pred_len).
"""

from data.data_loader import Dataset_Pred
from torch.utils.data import DataLoader

Data = Dataset_Pred
timeenc = 0 if args.embed!='timeF' else 1
flag = 'pred'; shuffle_flag = False; drop_last = False; batch_size = 1

freq = args.detail_freq

data_set = Data(
    root_path=args.root_path,
    data_path=args.data_path,
    flag=flag,
    size=[args.seq_len, args.label_len, args.pred_len],
    features=args.features,
    target=args.target,
    timeenc=timeenc,
    freq=freq
)
data_loader = DataLoader(
    data_set,
    batch_size=batch_size,
    shuffle=shuffle_flag,
    num_workers=args.num_workers,
    drop_last=drop_last)

len(data_set), len(data_loader)

"""## Visualization - Biểu đồ dữ liệu"""

# When we finished exp.train(setting) and exp.test(setting), we will get a trained model and the results of test experiment
# Dịch: Khi chúng tôi hoàn thành exp.train (cài đặt) và exp.test (cài đặt), chúng tôi sẽ nhận được một mô hình được đào tạo và kết quả của thử nghiệm kiểm tra
# The results of test experiment will be saved in ./results/{setting}/pred.npy (prediction of test dataset) and ./results/{setting}/true.npy (groundtruth of test dataset)

preds = np.load('./results/'+setting+'/pred.npy')
trues = np.load('./results/'+setting+'/true.npy')

# [samples, pred_len, dimensions]
preds.shape, trues.shape

import matplotlib.pyplot as plt
import seaborn as sns

# draw OT prediction
plt.figure()
plt.plot(trues[0,:,-1], label='GroundTruth')
plt.plot(preds[0,:,-1], label='Prediction')
plt.legend()
plt.show()

# draw HUFL prediction
plt.figure()
plt.plot(trues[0,:,0], label='GroundTruth')
plt.plot(preds[0,:,0], label='Prediction')
plt.legend()
plt.show()

from data.data_loader import Dataset_ETT_hour
from torch.utils.data import DataLoader

Data = Dataset_ETT_hour
timeenc = 0 if args.embed!='timeF' else 1
flag = 'test'; shuffle_flag = False; drop_last = True; batch_size = 1

data_set = Data(
    root_path=args.root_path,
    data_path=args.data_path,
    flag=flag,
    size=[args.seq_len, args.label_len, args.pred_len],
    features=args.features,
    timeenc=timeenc,
    freq=args.freq
)
data_loader = DataLoader(
    data_set,
    batch_size=batch_size,
    shuffle=shuffle_flag,
    num_workers=args.num_workers,
    drop_last=drop_last)

import os

args.output_attention = True

exp = Exp(args)

model = exp.model

setting = 'informer_ETTh1_ftM_sl96_ll48_pl24_dm512_nh8_el2_dl1_df2048_atprob_fc5_ebtimeF_dtTrue_mxTrue_exp_0'
path = os.path.join(args.checkpoints,setting,'checkpoint.pth')
model.load_state_dict(torch.load(path))

# attention visualization
idx = 0
for i, (batch_x,batch_y,batch_x_mark,batch_y_mark) in enumerate(data_loader):
    if i!=idx:
        continue
    batch_x = batch_x.float().to(exp.device)
    batch_y = batch_y.float()

    batch_x_mark = batch_x_mark.float().to(exp.device)
    batch_y_mark = batch_y_mark.float().to(exp.device)
    
    dec_inp = torch.zeros_like(batch_y[:,-args.pred_len:,:]).float()
    dec_inp = torch.cat([batch_y[:,:args.label_len,:], dec_inp], dim=1).float().to(exp.device)
    
    outputs,attn = model(batch_x, batch_x_mark, dec_inp, batch_y_mark)

attn[0].shape, attn[1].shape #, attn[2].shape

layer = 0
distil = 'Distil' if args.distil else 'NoDistil'
for h in range(0,8):
    plt.figure(figsize=[10,8])
    plt.title('Informer, {}, attn:{} layer:{} head:{}'.format(distil, args.attn, layer, h))
    A = attn[layer][0,h].detach().cpu().numpy()
    ax = sns.heatmap(A, vmin=0, vmax=A.max()+0.01)
    plt.show()

layer = 1
distil = 'Distil' if args.distil else 'NoDistil'
for h in range(0,8):
    plt.figure(figsize=[10,8])
    plt.title('Informer, {}, attn:{} layer:{} head:{}'.format(distil, args.attn, layer, h))
    A = attn[layer][0,h].detach().cpu().numpy()
    ax = sns.heatmap(A, vmin=0, vmax=A.max()+0.01)
    plt.show()






